## üß© What is Java-Based Configuration in Spring?

Java-based configuration allows us to configure Spring beans using Java classes **instead of** `applicationContext.xml` files. We use **annotations** like `@Configuration`, `@Bean`, `@Scope`, `@Primary`, etc.

---

## üî∑ Step-by-Step Guide to Java Configuration

### ‚úÖ 1. **Create a Configuration Class with `@Configuration`**

This class acts as a **replacement for XML configuration file**. It tells Spring that this class will define beans.

```java
import org.springframework.context.annotation.Configuration;

@Configuration
public class AppConfig {
    // Beans will be defined here
}
```

---

### ‚úÖ 2. **Define Beans using `@Bean`**

Inside the `@Configuration` class, you create methods that return objects. Annotate them with `@Bean` to register them with the Spring container.

```java
@Bean
public Car car() {
    return new Car(); // this will be a managed bean
}
```

**üî∏ Bean Naming:**

By default, the bean ID is the **method name** (`"car"` in the example above). You can change it using:

```java
@Bean(name = "myCar")
public Car car() {
    return new Car();
}
```

Or with multiple names:

```java
@Bean(name = {"myCar", "superCar"})
public Car car() {
    return new Car();
}
```

---

### ‚úÖ 3. **Initialize Container using `AnnotationConfigApplicationContext`**

This is the Java-based equivalent of `ClassPathXmlApplicationContext`.

```java
ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
Car myCar = context.getBean("myCar", Car.class);
```

---

### ‚úÖ 4. **Bean Dependency Injection**

When one bean depends on another, you can call that bean-creating method from within the configuration class:

```java
@Bean
public Engine engine() {
    return new Engine();
}

@Bean
public Car car() {
    return new Car(engine()); // inject Engine bean
}
```

Spring ensures **singleton scope by default**, so the `engine()` method will not be called again; it will inject the same bean.

---

## üîÑ XML vs Java Config Mapping Table

| Feature           | XML Config                             | Java Config                                         |
| ----------------- | -------------------------------------- | --------------------------------------------------- |
| Define a bean     | `<bean>`                               | `@Bean`                                             |
| Config class      | `<beans>`                              | `@Configuration`                                    |
| Bean ID           | `id="car"`                             | `@Bean(name="car")`                                 |
| Inject dependency | `<property name="engine" ref="eng" />` | Call `engine()` inside `car()`                      |
| Scope             | `scope="prototype"`                    | `@Scope("prototype")`                               |
| Primary bean      | `primary="true"`                       | `@Primary`                                          |
| Lazy init         | `lazy-init="true"`                     | `@Lazy`                                             |
| Autowiring        | `autowire="byName"` / `byType`         | `@Autowired` (with or without `@Qualifier`)         |
| Qualifier         | `ref="engine1"`                        | `@Qualifier("engine1")`                             |
| Inner bean        | `<bean><bean/></bean>`                 | Not used; just return inline bean in `@Bean` method |

---

## üîÅ Scope in Java Config

```java
@Bean
@Scope("prototype")
public Car car() {
    return new Car();
}
```

Available scopes:

* `"singleton"` (default)
* `"prototype"`
* `"request"` (for web)
* `"session"` (for web)

---

## ü•á Primary Bean

If you have multiple beans of the same type, mark one as `@Primary`:

```java
@Bean
@Primary
public Engine engine1() {
    return new Engine();
}

@Bean
public Engine engine2() {
    return new Engine();
}
```

Now, if you autowire `Engine`, `engine1` will be injected unless you specify `@Qualifier`.

---

## üéØ Qualifier

If there are multiple beans and you want to inject a specific one:

```java
@Bean
public Engine dieselEngine() {
    return new Engine("diesel");
}

@Bean
public Engine petrolEngine() {
    return new Engine("petrol");
}
```

```java
@Autowired
@Qualifier("petrolEngine")
private Engine engine;
```

---

## üïì Lazy Initialization

```java
@Bean
@Lazy
public Car lazyCar() {
    return new Car();
}
```

This bean won‚Äôt be created until it is actually needed.

---

## üîÉ Inner Beans in Java Config?

There is **no concept of inner beans** like XML, but you can define private helper methods or inline object construction.

```java
@Bean
public Car car() {
    return new Car(new Engine()); // Engine is not a managed bean
}
```

This behaves like an inner bean ‚Äî `Engine` is **not registered** in the Spring container.

---

## ‚úÖ Bonus: `@ComponentScan` + `@Component`

Java config also allows scanning packages for components:

```java
@Configuration
@ComponentScan(basePackages = "com.example")
public class AppConfig {}
```

Then annotate classes like:

```java
@Component
public class Engine {}
```

Now `Engine` is a managed bean ‚Äî no need to declare it in `@Bean`.

---

## ‚úÖ Final Java Config Example

```java
@Configuration
public class AppConfig {

    @Bean
    public Engine engine() {
        return new Engine("V8");
    }

    @Bean
    @Scope("prototype")
    public Car car() {
        return new Car(engine());
    }

    @Bean
    @Primary
    public Computer dellComputer() {
        return new Computer("Dell");
    }

    @Bean
    public Computer hpComputer() {
        return new Computer("HP");
    }
}
```

---

## üìò Summary

| Concept               | Java Annotation                |
| --------------------- | ------------------------------ |
| Configuration class   | `@Configuration`               |
| Bean definition       | `@Bean`                        |
| Scope                 | `@Scope("prototype")`          |
| Lazy init             | `@Lazy`                        |
| Autowiring            | `@Autowired`                   |
| Qualifier             | `@Qualifier("beanName")`       |
| Primary               | `@Primary`                     |
| Component scan        | `@ComponentScan("package")`    |
| Bean class annotation | `@Component`, `@Service`, etc. |
